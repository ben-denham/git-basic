<presentation>
  <title>Git - Source code control for humans</title>
  <subtitle></subtitle>
  <author>Andrew Ruthven / Evan Giles</author>
  <email>puck@catalyst.net.nz</email>

<!--

  <slide>
    <title>Title Here</title>
    <screenshot>filename.png</screenshot>
    <image src="file.jpg" />
    <bullet></bullet>
    <code syntax="perl"><![CDATA[
    ]]></code>
    <notes>
    </notes>
  </slide>

-->

  <slide>
    <title>Overview</title>
    <bullet>Why use revision control?</bullet>
    <bullet>Why use git?</bullet>
    <bullet>Create a new repository</bullet>
    <bullet>Managing files</bullet>
    <bullet>Change logs</bullet>
    <bullet>Branching</bullet>
    <bullet>Merging</bullet>
    <bullet>Remote repositories</bullet>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Why use revision control?</title>
    <bullet>Track software</bullet>
    <bullet>View history</bullet>
    <bullet>Look back to find when bugs where created</bullet>
    <bullet>Reasoning behind why something is how it is</bullet>
    <bullet>Roll back changes</bullet>
    <bullet>Apply kudos for effort</bullet>
    <bullet>Backups of your important stuff</bullet>
    <notes>
    Without revision control you end up with countless copies of files with no idea what is what.  Anecdote - files called readme.tt, readme.ttt, readme.tttt
    </notes>
  </slide>

  <slide>
    <title>What options are there?</title>
    <bullet>Lots of options...</bullet>
    <pause />
    <bullet>RCS</bullet>
    <bullet>CVS</bullet>
    <bullet>Subversion</bullet>
    <bullet>Darcs</bullet>
    <bullet>Perforce</bullet>
    <bullet>Bzr</bullet>
    <bullet>...</bullet>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Why not use git?</title>
    <bullet>There are some new concepts</bullet>
    <bullet>There are sooo many commands!</bullet>
    <pause />
    <bullet>You can safely ignore most of those commands.</bullet>
    <bullet>When you do want to send patches as emails, the command is there.</bullet>
    <bullet>When you want to import patches from a mailbox, the command is there.</bullet>
    <bullet>You get the idea.</bullet>
  </slide>

  <slide>
    <title>Why should you use git?</title>
    <bullet>The cool kids use it (including the Koha devs)</bullet>
    <bullet>It is fast</bullet>
    <bullet>As light weight as RCS, but <tt>much</tt> better!</bullet>
    <bullet>Branching is trivial</bullet>
    <bullet>Merging of branches actually makes sense</bullet>
    <bullet>You can be disconnected from the network, yet still continue working</bullet>
    <bullet>Once you master the concepts, you can do some really creative (and useful!) stuff</bullet>
  </slide>

  <slide>
    <title>Installing</title>
    <bullet>required <tt>git-core</tt></bullet>
    <bullet>useful <tt>gitk</tt></bullet>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Configuring</title>
    <bullet>Global data is stoed in <tt>$HOME/.git/config</tt></bullet>
    <bullet>Project data is stoed in <tt>$PROJECT/.git/config</tt></bullet>
    <bullet>use <tt>git config</tt> to see and modify it</bullet>
    <bullet>..or <tt>vim</tt></bullet>
    <bullet>Not actually required</bullet>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Some concepts to begin with</title>
    <bullet>git is just a bit different</bullet>
    <bullet>You get a <tt>checkout</tt> - so you can work with your project</bullet>
    <bullet>You get an <tt>index</tt>, which can be used to prepare commits</bullet>
    <bullet>You get a <tt>local repository</tt>,  which will hold all your commits</bullet>
    <bullet>The local repository can be aware of multiple branches</bullet>
    <bullet>Some branches are <tt>remote</tt></bullet>
  </slide>

  <slide>
    <title>Create a new repository</title>
    <bullet>Use <tt>git init</tt></bullet>
    <code>
puck@dirk:/tmp/test$ git init
Initialized empty Git repository in .git/
puck@dirk:/tmp/test$ 
    </code>
    <bullet>Check the status with <tt>git status</tt></bullet>
    <code>
puck@dirk:/tmp/test$ git status
# On branch master
#
# Initial commit
#
nothing to commit (create/copy files and use "git add" to track)
puck@dirk:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Managing Files - Add</title>
    <bullet>Make some changes...</bullet>
    <code>
puck@dirk:/tmp/test$ touch super-script.pl
    </code>
    <code>
puck@dirk:/tmp/test$ git status
# On branch master
#
# Initial commit
#
# Untracked files:
#   (use "git add &lt;file>..." to include in what will be committed)
#
#	super-script.pl
nothing added to commit but untracked files present (use "git add" to track)
    </code>
    <bullet>Tell git about files with <tt>git add &lt;files></tt></bullet>
    <code>
puck@dirk:/tmp/test$ git add super-script.pl 
    </code>
    <code>
puck@dirk:/tmp/test$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached &lt;file>..." to unstage)
#
#       new file: super-script.pl
#
puck@dirk:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Managing Files - Change an existing file</title>
    <bullet>Make some changes...</bullet>
    <code>
puck@dirk:/tmp/test$ echo DATA > super-script.pl
    </code>
    <code>
puck@dirk:/tmp/test$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached &lt;file>..." to unstage)
#
#	new file:   super-script.pl
#
# Changed but not updated:
#   (use "git add &lt;file>..." to update what will be committed)
#   (use "git checkout -- &lt;file>..." to discard changes in working directory)
#
#	modified:   super-script.pl
#
    </code>
    <bullet>...so, git is saying that it knows you have changed the file since you added it</bullet>
    <bullet>Ie.  The version in the checkout is different to the version in the index</bullet>
    <bullet>We need to tell git that you intend to commit the checked out version, with <tt>git add &lt;files></tt></bullet>
    <code>
puck@dirk:/tmp/test$ git add super-script.pl 
    </code>
    <code>
puck@dirk:/tmp/test$ git status
# On branch master
#
# Initial commit
#
# Changes to be committed:
#   (use "git rm --cached &lt;file>..." to unstage)
#
#	new file:   super-script.pl
#
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Commiting changes</title>
    <bullet>We have told git about our changes</bullet>
    <bullet>We haven't actually committed anything yet</bullet>
    <bullet>This is deliberate - so you can build up more complex commits</bullet>
    <bullet>Every change needs to be committed</bullet>
    <bullet>Commit with <tt>git commit &lt;files></tt></bullet>
    <bullet>You will be asked for a commit message (please include the WR number)</bullet>
    <code>
puck@dirk:/tmp/test$ git commit super-script.pl 
Created commit ae54011: Add a message.
 1 files changed, 3 insertions(+), 0 deletions(-)
 create mode 100644 super-script.pl
puck@dirk:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Commiting changes - some useful options</title>
    <bullet>You don't <tt>have</tt> to add all your changes manually</bullet>
    <code>
puck@dirk:/tmp/test$ git commit &lt;file>
    </code>
    <code>
puck@dirk:/tmp/test$ git commit -a
    </code>
    <bullet>You don't have to use an editor...</bullet>
    <code>
puck@dirk:/tmp/test$ git commit -m 'commit message goes here'
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Managing Files - Permissions</title>
    <bullet>Oops, that file isn't executable</bullet>
    <bullet>Unlike <tt>some</tt> revision control systems, git is aware of file permissions</bullet>
    <code>
puck@dirk:/tmp/test$ chmod 755 super-script.pl 
puck@dirk:/tmp/test$ git commit super-script.pl 
Created commit 378af93: Make it executable.
 0 files changed, 0 insertions(+), 0 deletions(-)
 mode change 100644 => 100755 super-script.pl
puck@dirk:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>


  <slide>
    <title>Managing Files - Move</title>
    <bullet>To rename a file use <tt>git mv &lt;source> &lt;dest></tt></bullet>
    <code>
puck@dirk:/tmp/test$ git mv super-script.pl silly-script.pl
    </code>
    <code>
puck@dirk:/tmp/test$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file>..." to unstage)
#
#       renamed:    super-script.pl -> silly-script.pl
#
puck@dirk:/tmp/test$ 
    </code>
    <bullet>This has changed our checkout, and the index, so we are ready to commit the change</bullet>
    <code>
puck@dirk:/tmp/test$ git commit
Created commit fabd446: Rename the file.
 1 files changed, 0 insertions(+), 0 deletions(-)
 rename super-script.pl => silly-script.pl (100%)
puck@dirk:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Managing Files - Delete</title>
    <bullet>To delete a file use <tt>git rm &lt;files></tt></bullet>
    <code>
# This won't actually work, because we haven't created "another-script.pl"
# ... but you can try it, if you like....
    </code>
    <code>
puck@dirk:/tmp/test$ git rm another-script.pl 
    </code>
    <code>
puck@dirk:/tmp/test$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file>..." to unstage)
#
#       deleted:    another-script.pl
#
puck@dirk:/tmp/test$ 
    </code>
    <bullet>And commit the change</bullet>
    <code>
puck@dirk:/tmp/test$ git commit
Created commit bd10c5f: Remove another-script.pl
 0 files changed, 0 insertions(+), 0 deletions(-)
 delete mode 100644 another-script.pl
puck@dirk:/tmp/test$ 
    </code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Change Logs</title>
    <bullet>See what is going on</bullet>
    <bullet>Use <tt>git log</tt></bullet>
    <bullet>By default the output is piped into $PAGER</bullet>
<code>
<![CDATA[
puck@dirk:/tmp/test$ git log
commit bd10c5f5179b4c6b52d586cc5355e3018b3c8c37
Author: Andrew Ruthven <puck@catalyst.net.nz>
Date:   Fri May 9 17:08:02 2008 +1200

    Remove another-script.pl

commit cc260920d4b1aa87e000d2a52643b22b725d4922
Author: Andrew Ruthven <puck@catalyst.net.nz>
Date:   Fri May 9 17:07:35 2008 +1200

    Add a test script.

commit fabd44619bd37f47b9e1e193ee4ded97e64f8f4a
Author: Andrew Ruthven <puck@catalyst.net.nz>
Date:   Fri May 9 17:03:04 2008 +1200

    Rename the file.

commit 378af932284a01c8cb6c3de202182ecac0fa7969
Author: Andrew Ruthven <puck@catalyst.net.nz>
Date:   Fri May 9 17:02:24 2008 +1200

    Make it executable.

commit ae540117822f58ca7974c69fe13270959cc04f34
Author: Andrew Ruthven <puck@catalyst.net.nz>
Date:   Fri May 9 17:01:41 2008 +1200

    Add a message.
puck@dirk:/tmp/test$ git log | cat
commit bd10c5f5179b4c6b52d586cc5355e3018b3c8c37
Author: Andrew Ruthven <puck@catalyst.net.nz>
Date:   Fri May 9 17:08:02 2008 +1200

    Remove another-script.pl

commit cc260920d4b1aa87e000d2a52643b22b725d4922
Author: Andrew Ruthven <puck@catalyst.net.nz>
Date:   Fri May 9 17:07:35 2008 +1200

    Add a test script.

commit fabd44619bd37f47b9e1e193ee4ded97e64f8f4a
Author: Andrew Ruthven <puck@catalyst.net.nz>
Date:   Fri May 9 17:03:04 2008 +1200

    Rename the file.

commit 378af932284a01c8cb6c3de202182ecac0fa7969
Author: Andrew Ruthven <puck@catalyst.net.nz>
Date:   Fri May 9 17:02:24 2008 +1200

    Make it executable.

commit ae540117822f58ca7974c69fe13270959cc04f34
Author: Andrew Ruthven <puck@catalyst.net.nz>
Date:   Fri May 9 17:01:41 2008 +1200

    Add a message.
puck@dirk:/tmp/test$ 
]]>
</code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Change Logs</title>
    <bullet>Can specify a file or directory</bullet>
<code>
puck@dirk:/tmp/test$ git log silly-script.pl 
</code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Change Logs - Annotate</title>
    <bullet>Show who made changes to what line</bullet>
    <bullet>Also known as the blame log</bullet>
<code>
puck@dirk:/tmp/test$ git blame silly-script.pl
puck@dirk:/tmp/test$ git blame silly-script.pl  | cat
^ae54011 super-script.pl (Andrew Ruthven 2008-05-09 17:01:41 +1200 1) #!/usr/bin/perl -w
^ae54011 super-script.pl (Andrew Ruthven 2008-05-09 17:01:41 +1200 2) 
^ae54011 super-script.pl (Andrew Ruthven 2008-05-09 17:01:41 +1200 3) print "silly script\n";
2c08faf4 silly-script.pl (Bad Coder      2008-05-09 17:18:18 +1200 4) I'm in ur code, breaking ur stuff.
puck@dirk:/tmp/test$ 
</code>
    <bullet>Who is this Bad Coder fella?</bullet>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Change Logs - GUI</title>
    <bullet>Not strictly change logs, but...</bullet>
    <bullet>gitk</bullet>
    <bullet>git gui</bullet>
    <bullet>Many more</bullet>
    <bullet> ( Demo )</bullet>
  </slide>

  <slide>
    <title>Some more concepts - commits</title>
    <bullet>It is important to understand that git thinks in <tt>commits</tt></bullet>
    <bullet>Each commit builds upon a previous commit</bullet>
    <bullet>Each commit refers to a previous commit (it's parent)</bullet>
    <bullet>...and a series of commits provide a complete history of the project</bullet>
    <bullet><tt>gitk</tt> lets you visualise the commit history, which helps a lot</bullet>
    <bullet>Commits can be referenced by their SHA1 checksum</bullet>
    <bullet> - or an abbreviation of it</bullet>
    <bullet> - or by a number of things that might refer to them</bullet>
  </slide>

  <slide>
    <title>Branching - List</title>
    <bullet>To show branches use <tt>git branch</tt></bullet>
<code>
puck@dirk:/tmp/test$ git branch
* master
puck@dirk:/tmp/test$ 
</code>
    <bullet>Only one branch called <tt>master</tt></bullet>
    <bullet>The '*' indicates that it is your current branch</bullet>
  </slide>

  <slide>
    <title>Branching - Create</title>
    <bullet>Use <tt>git checkout -b &lt;new-name></tt></bullet>
<code>
puck@dirk:/tmp/test$ git checkout -b new-branch
Switched to a new branch "new-branch"
puck@dirk:/tmp/test$ git branch
  master
* new-branch
puck@dirk:/tmp/test$ 
</code>
    <bullet>Will create "new-branch", and check it out for you </bullet>
    <bullet>new-branch will be created at the commit your previously had checked out</bullet>
    <bullet>Can also create a new branch at another location</bullet>
<code>
puck@dirk:/tmp/test$ git checkout -b another-branch master
Switched to a new branch "another-branch"
puck@dirk:/tmp/test$ git branch
* another-branch
  master
  new-branch
puck@dirk:/tmp/test$ 
</code>
  </slide>

  <slide>
    <title>Branching - Change Branch</title>
    <bullet>Just use <tt>git checkout</tt> without the <tt>-b</tt></bullet>
<code>
puck@dirk:/tmp/test$ git checkout new-branch
Switched to branch "new-branch"
puck@dirk:/tmp/test$ git branch
  another-branch
  master
* new-branch
puck@dirk:/tmp/test$ 
</code>
    <bullet>Don't forget to see how this is shown in <tt>gitk</tt></bullet>
  </slide>

  <slide>
    <title>Branching - What's the deal?</title>
    <bullet>You can make commits on a branch without polluting other branches</bullet>
<code>
puck@dirk:/tmp/test$ echo "# From new-branch" >> silly-script.pl 
puck@dirk:/tmp/test$ git commit silly-script.pl 
Created commit a6ed2cf: From new-branch
 1 files changed, 1 insertions(+), 0 deletions(-)
puck@dirk:/tmp/test$ 
</code>
    <bullet>Check the file, then jump to another branch, it ain't there</bullet>
<code>
puck@dirk:/tmp/test$ cat silly-script.pl 
#!/usr/bin/perl -w

print "silly script\n";
# From new-branch
puck@dirk:/tmp/test$ git checkout master
Switched to branch "master"
puck@dirk:/tmp/test$ cat silly-script.pl 
#!/usr/bin/perl -w

print "silly script\n";
puck@dirk:/tmp/test$ 
</code>
  </slide>

  <slide>
    <title>Branching - Why?</title>
    <bullet>Many (most) projects have a branch for each release</bullet>
    <bullet>Branches are useful for experimntal features / refactoring</bullet>
    <bullet>Branches happen (without even trying) when several people try to work on the same project - but I'll explain that soon ;)</bullet>
  </slide>

  <slide>
    <title>Merging - Simple Case</title>
    <bullet>You should now be on the master branch</bullet>
    <code>
puck@dirk:/tmp/test$ git status
# On branch master
nothing to commit (working directory clean)
puck@dirk:/tmp/test$ 
    </code>
    <bullet>Just say <tt>git merge &lt;other branch></tt></bullet>
    <code>
puck@dirk:/tmp/test$ git merge new-branch
Updating e766bfb..a6ed2cf
Fast forward
 silly-script.pl |    1 +
 1 files changed, 1 insertions(+), 0 deletions(-)
puck@dirk:/tmp/test$ 
    </code>
    <bullet>If there are no conflicts, this will make a new commit object</bullet>
    <bullet>In this case the commit message is automatically created</bullet>
<code>
Merge branch 'new-branch'

Conflicts:

        silly-script.pl

</code>
  </slide>

  <slide>
    <title>Merging - How does it look?</title>
    <bullet>Looking at the trees in gitk is cool.</bullet>
  </slide>

  <slide>
    <title>Merging - With conflicts</title>
    <bullet>Conflicts are more difficult</bullet>
    <bullet>If there are conflicts then git will stop and let you fix it.</bullet>
    <bullet>Lots of tools to help fix things up.  Hand edit, xxdiff, smartmerge, etc</bullet>
<code>
puck@dirk:/tmp/test$ git merge new-branch
Auto-merged silly-script.pl
CONFLICT (content): Merge conflict in silly-script.pl
Automatic merge failed; fix conflicts and then commit the result.
puck@dirk:/tmp/test$ cat silly-script.pl 
#!/usr/bin/perl -w

&lt;&lt;&lt;&lt;&lt;&lt;&lt; HEAD:silly-script.pl
print "silly script - change on master\n";
=======
print "change on new-branch - silly script\n";
>>>>>>> new-branch:silly-script.pl
# From new-branch
puck@dirk:/tmp/test$ 
</code>
    <bullet>Fix it, in this case use vi</bullet>
<code>
puck@dirk:/tmp/test$ vi silly-script.pl 
puck@dirk:/tmp/test$ cat silly-script.pl 
#!/usr/bin/perl -w

print "change on new-branch - silly script - change on master\n";
# From new-branch
</code>
    <bullet>Now that we've fixed the code, tell git that it has been fixed and commit it</bullet>
<code>
puck@dirk:/tmp/test$ git add silly-script.pl 
puck@dirk:/tmp/test$ git commit
Created commit a411f2a: Merge branch 'new-branch'
puck@dirk:/tmp/test$ 
</code>
    <bullet>In this case the commit message is automatically created</bullet>
<code>
Merge branch 'new-branch'

Conflicts:

        silly-script.pl

</code>
  </slide>

  <slide>
    <title>Creating Repositories - Revisted</title>
    <bullet>There are many different ways to get remote repositories, some are:</bullet>
    <bullet>Create a new one (we've already covered this)</bullet>
    <code>
puck@dirk:/tmp/test$ git init
Initialized empty Git repository in .git/
puck@dirk:/tmp/test$ 
    </code>
    <bullet>In practise, you're more likely to use <tt>git clone &lt;URL> &lt;local dir></tt></bullet>
    <bullet>&lt;local dir> is optional</bullet>
    <bullet>To check out the source code for this course</bullet>
    <code>
puck@dirk:/tmp$ git clone git+ssh://gitprivate.catalyst.net.nz/git/private/git-training.git
Cloning into git-training...
remote: Counting objects: 90, done.
remote: Compressing objects: 100% (43/43), done.
remote: Total 90 (delta 44), reused 90 (delta 44)
Receiving objects: 100% (90/90), 31.62 KiB, done.
Resolving deltas: 100% (44/44), done.
puck@dirk:/tmp$ 
    </code>
    <code>
puck@dirk:/tmp$ cd git-training
puck@dirk:/tmp/git-training$ ls talk.xml
talk.xml
    </code>
  </slide>

  <slide>
    <title>Remote repositories - URLs </title>
    <bullet>Clone an existing repository via HTTP</bullet>
<code>
puck@dirk:/tmp$ git clone http://gitprivate.catalyst.net.nz/git-training-example.git
</code>
    <bullet>Clone an existing repository via SSH</bullet>
<code>
puck@dirk:/tmp$ git clone git+ssh://git.catalyst.net.nz/git/private/git-training-example.git
</code>
    <bullet>Clone an existing repository Local repository (this is just a bit mad)</bullet>
<code>
puck@dirk:/tmp$ git clone test test2
</code>
  </slide>

  <slide>
    <title>Sharing your changes with others</title>
    <bullet>If we assume we have a cloned repo....</bullet>
    <bullet>and we have committed some changes....</bullet>
    <bullet>To share those changes we would normally use <tt>git push</tt></bullet>
    <code>
### Make a reasonable example here....
puck@dirk:/tmp$ git push
puck@dirk:/tmp$ 
    </code>
    <bullet>Only, it doesn't always let you push....</bullet>
    <bullet>Why not?</bullet>
    <bullet>What should you do next?</bullet>
    <bullet>( Demo / Discussion )</bullet>
  </slide>


  <slide>
    <title>Remote repositories - Local branch</title>
    <bullet>You may want to work on a remote branch</bullet>
    <bullet>Very similar to copying local branches</bullet>
<code>
puck@dirk:/tmp/test2$ git checkout -b pucks-working origin/new-branch
Switched to a new branch "pucks-working"
puck@dirk:/tmp/test2$ git branch -a
  master
* pucks-working
  origin/HEAD
  origin/another-branch
  origin/master
  origin/new-branch
puck@dirk:/tmp/test2$ 
</code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Remote repositories - Local changes</title>
    <bullet>Very similar work flow</bullet>
<code>
puck@dirk:/tmp/test2$ vi silly-script.pl 
puck@dirk:/tmp/test2$ cat silly-script.pl 
#!/usr/bin/perl -w

print "change on new-branch - silly script - change on master\n";
# From new-branch
# Make a change on test2.
puck@dirk:/tmp/test2$ git commit silly-script.pl 
Created commit c2f770f: Change on test2 clone.
 1 files changed, 1 insertions(+), 0 deletions(-)
puck@dirk:/tmp/test2$ git push
Everything up-to-date
puck@dirk:/tmp/test2$ 
</code>
    <bullet>We we need to push our changes</bullet>
<code>
puck@dirk:/tmp/test2$ git push
updating 'refs/heads/master'
  from 2f8f119f7f197d1b6c3af53cc1aea29215702fba
  to   c2f770f85e11046187075c53d640998aa767cf7e
Generating pack...
Done counting 5 objects.
Result has 3 objects.
Deltifying 3 objects...
 100% (3/3) done
Writing 3 objects...
 100% (3/3) done
Unpacking 3 objects...
 100% (3/3) done
Total 3 (delta 1), reused 0 (delta 0)
refs/heads/master: 2f8f119f7f197d1b6c3af53cc1aea29215702fba -> c2f770f85e11046187075c53d640998aa767cf7e
puck@dirk:/tmp/test2$ 
</code>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Remote repositories - Fetch</title>
    <bullet>Lots of different approaches</bullet>
    <bullet>Some people use <tt>git pull</tt></bullet>
    <bullet>Others use <tt>git fetch</tt> then <tt>git rebase</tt></bullet>
    <bullet>Still others use stacked git</bullet>
    <bullet>I use <tt>git fetch</tt> then <tt>git rebase</tt> so I have a bit more control</bullet>
<code>
puck@dirk:/tmp/test2$ git fetch
* refs/remotes/origin/master: fast forward to branch 'master' of /tmp/test/
  old..new: 2f8f119..c2f770f
puck@dirk:/tmp/test2$ git rebase origin/master
Current branch master is up to date.
puck@dirk:/tmp/test2$ 
</code>
    <bullet>No changes required</bullet>
    <bullet>If we had local changes they'd be "replayed" on the top of the changes we'd fetched</bullet>
  </slide>

  <slide>
    <title>Abort a change (early)</title>
    <bullet>What if you screw things up?</bullet>
    <bullet>If the error is just in you checkout, you can run <tt>git reset --hard</tt></bullet>
    <bullet>This throws away <b>all</b> local changes, except unknown files</bullet>
    <bullet>You could also use <tt>gitk</tt></bullet>
  </slide>

  <slide>
    <title>Abort a change.. (not that early)</title>
    <bullet>What if you screw things up?</bullet>
    <code>
puck@dirk:/tmp/test$ echo "I am sooo drunk!" > silly-script.pl 
    </code>
    <bullet>... and tell git we are going to commit something</bullet>
    <code>
puck@dirk:/tmp/test$ git add silly-script.pl 
puck@dirk:/tmp/test$ git status
# On branch master
# Changes to be committed:
#   (use "git reset HEAD &lt;file>..." to unstage)
#
#       modified:   silly-script.pl
#
     </code>
     <bullet>... and then decide that it was all a mistake</bullet>
     <bullet>Use <tt>git reset</tt> to undo the <tt>git add</tt></bullet>
     <code>
puck@dirk:/tmp/test$ git reset HEAD silly-script.pl 
silly-script.pl: needs update
     </code>
     <bullet>And <tt>git checkout</tt> to undo the edit</bullet>
     <code>
puck@dirk:/tmp/test$ git checkout silly-script.pl 
puck@dirk:/tmp/test$ git status
# On branch master
nothing to commit (working directory clean)
puck@dirk:/tmp/test$ 
    </code>
    <bullet>You could also use <tt>gitk</tt></bullet>
    <notes>
    </notes>
  </slide>

  <slide>
    <title>Abort a change (late)</title>
    <bullet>Sometimes we want to undo a commit</bullet>
    <bullet>Many different ways, one way to leave an audit trail:</bullet>
    <bullet><tt>git revert &lt;commit ID></tt></bullet>
<code>
puck@dirk:/tmp/test$ git revert 2c08faf4
Finished one revert.
Created commit e766bfb: Revert "Break the code!"
 1 files changed, 0 insertions(+), 1 deletions(-)
puck@dirk:/tmp/test$ 
</code>
  </slide>


  <slide>
    <title>The End</title>
    <bullet>Questions?</bullet>
    <pause/>
    <bullet>http://www.eecs.harvard.edu/~cduan/technical/git/</bullet>
    <bullet>http://www.alistapart.com/articles/get-started-with-git/</bullet>
    <notes>
    </notes>
  </slide>

</presentation>
